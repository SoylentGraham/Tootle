#include "TLSpotify.h"




namespace TLSpotify
{
	extern sp_session_callbacks	g_Callbacks;
}


//	callback info
sp_session_callbacks TLSpotify::g_Callbacks = {
	NULL, //	&TLSpotify::OnLoggedIn,
	NULL, //	&TLSpotify::OnLoggedOut,
	NULL, //	&TLSpotify::OnMetadataUpdated,
	NULL, //	&TLSpotify::OnConnectionError,
    NULL,
    NULL, //	&notify_main_thread,
    NULL,
    NULL,
    NULL, //	&log_message
	NULL,	//	end_of_track
	NULL,	//	streaming_error
	NULL,	//	userinfo_updated
};


THeapArray<TLSpotify::TSession*> TLSpotify::Private::g_Sessions;



//--------------------------------------------------------
//	session handler
//--------------------------------------------------------
TLSpotify::TSession::TSession(const TArray<u8>& Key,const TString& AgentName,const TString& UserName,const TString& Password) :
	m_AgentName	( AgentName ),
	m_UserName	( UserName ),
	m_Password	( Password ),
	m_pSession	( NULL ),
	m_Key		( Key ),
	m_EventProcessTimeout	( 0.f )
{
	//	add to session list
	Private::g_Sessions.Add( this );
}

TLSpotify::TSession::~TSession()
{
	//	cleanup session
	Shutdown();
	
	//	remove from session list
	Private::g_Sessions.Remove( this );
}


//--------------------------------------------------------
//	init the session
//--------------------------------------------------------
bool TLSpotify::TSession::Initialise(TRef& ErrorRef)
{
	//	init session
	if ( !m_pSession )
	{
		sp_session_config config;
		
		config.api_version = SPOTIFY_API_VERSION;
		
		// The path of the directory to store the cache. This must be specified.
		// Please read the documentation on preferred values.
		config.cache_location = "tmp";
		
		// The path of the directory to store the settings. This must be specified.
		// Please read the documentation on preferred values.
		config.settings_location = "tmp";
		
		// The key of the application. They are generated by Spotify,
		// and are specific to each application using libspotify.
		config.application_key = m_Key.GetData();
		config.application_key_size = m_Key.GetSize();
		
		// This identifies the application using some
		// free-text string [1, 255] characters.
		TFixedArray<char,255> AgentString;
		m_AgentName.GetAnsi( AgentString );
		config.user_agent = AgentString.GetData();
		
		// Register the callbacks.
		config.callbacks = &g_Callbacks;
		
		//	https://developer.spotify.com/en/libspotify/docs/group__session.html
		//	In the future, this will be renamed to sp_session_create() and will have a corresponding sp_session_release() function.
		sp_error Error = sp_session_init( &config, &m_pSession );
		
		if ( Error != SP_ERROR_OK )
		{
			//sp_error_message(error));
			ErrorRef = "Init";
			Shutdown();
			return false;
		}
		
		//	where is the session?
		if ( !m_pSession )
		{
			ErrorRef = "NoSession";
			Shutdown();
			return false;
		}
	}
	
	//	log in session
	if ( !IsLoggedIn() )
	{
		TFixedArray<char,255> UserNameString;
		m_UserName.GetAnsi( UserNameString );
		TFixedArray<char,255> PasswordString;
		m_Password.GetAnsi( PasswordString );
		
		//	attempt login
		sp_error Error = sp_session_login( m_pSession, UserNameString.GetData(), PasswordString.GetData() );
		if ( Error != SP_ERROR_OK )
		{
			ErrorRef = "Login";
			Shutdown();
			return false;
		}
		
		//	logged in! fetch the user
		m_pUser = sp_session_user( m_pSession );
		if ( !m_pUser )
		{
			ErrorRef = "NoUser";
			//	set pointer to something so we attempt to logout, even though it's not valid
			m_pUser = (sp_user*)0xdeadf00d;
			Shutdown();
			return false;
		}
	}
	
	return true;
}


//--------------------------------------------------------
//	 cleanup the session
//--------------------------------------------------------
void TLSpotify::TSession::Shutdown()
{
	//	logout first
	if ( m_pUser )
	{
		sp_error Error = sp_session_logout( m_pSession );
		if ( Error != SP_ERROR_OK )
			TLDebug_Break("Error logging out");
		m_pUser = NULL;
	}
	
	//	cleanup session
	if ( m_pSession )
	{
		//	there are no multiple sessions in libspotify atm, so we cannot cleanup the session.
		m_pSession = NULL;
	}
	
}

/*
 bool TLSpotify::TSession::UpdatePlaylists()
 {
 if ( m_pPlaylistContainer )
 return true;
 
 //	get container
 m_pPlaylistContainer = sp_session_playlistcontainer( m_pSession );
 if ( !m_pPlaylistContainer )
 {
 TLDebug_Break("Failed to get playlist container");
 return false;
 }
 
 //	enumerate playlsts
 int PlaylistCount = sp_playlistcontainer_num_playlists( m_pPlaylistContainer );
 for ( u32 i=0;	i<PlaylistCount;	i++ )
 {
 sp_playlist* pPlaylist = sp_playlistcontainer_playlist( m_pPlaylistContainer, i);
 if ( !pPlaylist )
 continue;
 
 //	add to list of playlists
 TPtr<TPlaylist> pPlaylistPtr = new TPlaylist( *pPlaylist );
 m_Playlists.Add( pPlaylistPtr );
 }
 
 return true;
 }
 
 
 bool TLSpotify::TSession::CreatePlaylist(const TString& PlaylistName)
 {
 //sp_playlistcontainer_add_new_playlist
 TLDebug_Break("todo");
 return false;
 }
 
 
 
 TLSpotify::TPlaylist::TPlaylist(sp_playlist& Playlist) :
 m_pPlaylist		( &Playlist )
 {
 //	setup callbacks
 //sp_playlist_add_callbacks( m_pPlaylist, &PlaylistCallbacks, this );
 
 //	get name
 m_Name = sp_playlist_name( m_pPlaylist );
 
 TDebugString Debug_String;
 Debug_String << "Created playlist " << m_Name;
 TLDebug_Print( Debug_String );
 }
 */

TLSpotify::TTrack::TTrack() :
m_pTrack	( NULL ),
m_Loaded	( SyncWait )
{
	UpdateInfo();
}


TLSpotify::TTrack::TTrack(sp_track& Track) :
m_pTrack	( NULL ),
m_Loaded	( SyncWait )
{
	SetTrack( Track );
}

TLSpotify::TTrack::~TTrack()
{
	ReleaseTrack();
}


void TLSpotify::TTrack::ReleaseTrack()
{
	if( m_pTrack )
	{
		sp_track_release( m_pTrack );
		m_pTrack = NULL;
		m_Loaded = SyncWait;
		UpdateInfo();
	}
}

void TLSpotify::TTrack::SetTrack(sp_track& Track)
{
	//	release existing
	ReleaseTrack();
	
	//	add reference
	m_pTrack = &Track;
	sp_track_add_ref( m_pTrack );
	UpdateInfo();
}


SyncBool TLSpotify::TTrack::Initialise()
{
	if ( !m_pTrack )
	{
		m_Loaded = SyncFalse;
		return m_Loaded;
	}
	
	//	check track state
	if ( m_Loaded == SyncWait )
	{
		sp_error Error = sp_track_error( m_pTrack );
		if ( Error == SP_ERROR_OK )
		{
			m_Loaded = SyncTrue;
			UpdateInfo();
		}
		else if ( Error == SP_ERROR_IS_LOADING )
		{
			m_Loaded = SyncWait;
		}
		else
		{
			m_pTrack = NULL;
			m_Loaded = SyncFalse;
		}
	}
	
	return m_Loaded;
}


void TLSpotify::TTrack::UpdateInfo()
{
	if ( m_pTrack )
		m_Title = sp_track_name( m_pTrack );

	//	just verify the loaded state
	if ( IsReady() && !sp_track_is_loaded( m_pTrack ) )
	{
		TLDebug_Break("track not loaded");
		m_Loaded = SyncFalse;
	}
	
	//	unknown data
	if ( !IsReady() )
	{
		m_Title = "???";
		return;
	}
	
	//	get info
	m_Title = sp_track_name( m_pTrack );
	/*
	 sp_album* pAlbum = sp_track_album( m_pTrack );
	 m_Album = pAlbum ? pAlbum->
	 
	 //	enum artists
	 int ArtistCount = sp_track_num_artists( m_pTrack );
	 if ( ArtistCount == 0 )
	 m_Artist = "???";
	 for ( u32 a=0;	a<ArtistCount;	a++ )
	 {
	 sp_artist* pArtist = sp_track_artist( m_pTrack, a );
	 if ( !pArtist )
	 m_Artist << "???";
	 else 
	 m_Artist << pArtist->
	 */	
}


//----------------------------------------------
//	get track info from URI
//----------------------------------------------
TRef TLSpotify::TSession::FindTrack(const TString& URI)
{
	THeapArray<char> UriString;
	URI.GetAnsi( UriString );
	
	//	find link
	sp_link *link = sp_link_create_from_string( UriString.GetData() );
    if (!link) 
		return TRef();
	
	//	get track from the link
	sp_track* pTrack = sp_link_as_track( link );
	if ( !pTrack )
	{
		TDebugString Debug_String;
		Debug_String << "URI " << URI << " is not a track";
		TLDebug_Print( Debug_String );
		return TRef();
	}
	
	//	create new track info
	TRef TrackRef = AddTrack( *pTrack );
	
	const char* TrackName = sp_track_name( pTrack );
	
    //	The create function will have increased the reference count for us so release
    sp_link_release(link);
	
	return TrackRef;
}



//---------------------------------------------------
//	add this track to our cache	(or return existing)
//---------------------------------------------------
TRef TLSpotify::TSession::AddTrack(sp_track& Track)
{
	//	see if track already exists
	TRef ExistingTrackKey;
	for ( u32 i=0;	!ExistingTrackKey.IsValid() && i<m_Tracks.GetSize();	i++ )
	{
		TPtr<TLSpotify::TTrack>& pTrack = m_Tracks.GetItemAt(i);
		if ( pTrack == Track )
			ExistingTrackKey = m_Tracks.GetKeyAt(i);
	}
	
	//	found existing entry
	if ( ExistingTrackKey.IsValid() )
		return ExistingTrackKey;
	
	//	make up new track key
	m_LastTrackKey.Increment();
	TRef NewTrackKey = m_LastTrackKey;
	
	TPtr<TTrack> pTrack = new TTrack( Track );
	m_Tracks.Add( NewTrackKey, pTrack );
	
	return NewTrackKey;
}

/*

bool TLSpotify::TSession::PlayTrack(TRefRef TrackRef,float InitialTime)
{
	//	load track
	if ( !SetCurrentTrack( TrackRef ) )
		return false;
	
	//	set seek
	if ( !SeekCurrentTrack(InitialTime) )
	{
		UnloadTrack();
		return false;
	}
	
	//	start play
	if ( !PlayCurrentTrack(true) )
	{
		UnloadTrack();
		return false;
	}
	
	return true;
}
 */

TLSpotify::TTrack* TLSpotify::TSession::GetTrack(TRefRef TrackRef)
{
	TPtr<TLSpotify::TTrack>& pTrack = m_Tracks.FindPtr( TrackRef );
	return pTrack;
}

void TLSpotify::TSession::UnloadTrack()
{
	sp_session_player_unload( m_pSession );
	m_CurrentTrack = TRef();
}

SyncBool TLSpotify::TSession::LoadTrack(TRefRef Track)
{
	//	get track
	TTrack* pTrack = GetTrack( Track );
	if ( !pTrack )
		return SyncFalse;
	
//	sp_session_player_load( pTrack->GetTrack(), m_pSession );
	
	TLDebug_Break("todo");
	return SyncFalse;
}


bool TLSpotify::TSession::SeekCurrentTrack(float TimeSecs)
{
	if ( !m_CurrentTrack.IsValid() )
		return false;
	
	TLDebug_Break("todo");
	return false;
}


//------------------------------------------------
//	if Play is false, the track is paused
//------------------------------------------------
bool TLSpotify::TSession::PlayCurrentTrack(bool Play)
{
	if ( !m_CurrentTrack.IsValid() )
		return false;
	
	TLDebug_Break("todo");
	return false;
}


//------------------------------------------------
//	asynch updates
//------------------------------------------------
void TLSpotify::TSession::Update(float Timestep)
{
	if ( m_pSession )
	{
		//	update session events when we're allowed
		m_EventProcessTimeout -= Timestep;
		
		//	time for another update
		if ( m_EventProcessTimeout <= 0.f )
		{
			int TimeoutMs = -1;
			sp_session_process_events( m_pSession, &TimeoutMs );
			m_EventProcessTimeout += TimeoutMs / 1000;
		}
	}
	
	//	update tracks
	for ( u32 t=0;	t<m_Tracks.GetSize();	t++ )
	{
		TTrack& Track = *m_Tracks.GetItemAt(t);
		Track.Initialise();
	}
	
}


//------------------------------------------------
//	fetch track info, and queue it up for download
//------------------------------------------------
TRef TLSpotify::TSession::DownloadTrack(const TString& Url)
{
	//	lookup track info
	TRef TrackRef = FindTrack( Url );

	//	if that failed, the track (url) doesn't exist
	if ( !TrackRef.IsValid() )
		return TrackRef;

	//	queue up for download
	m_DownloadTracks.AddUnique( TrackRef );

	return TrackRef;
}



